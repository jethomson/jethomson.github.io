<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<title>scripts/examples/example05_Hr_cyan_LED.m</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="generator" content="highlight.m &copy; 2003 Guillaume Flandin">
<style type="text/css">
  .comment {color: #228B22;}
  .string {color: #B20000;}
  .keyword, .cont {color: #0000FF;}
  .cont {text-decoration: underline;}
  .code {color: #000000;}
</style>
</head>
<body>
<pre class="mcode">0001 <span class="comment">%</span>
0002 <span class="comment">% This script demonstrates using so.Hr, the spectrometer's calibrated system</span>
0003 <span class="comment">% function, and the output of a TSL230 irradiance sensor to create and check</span>
0004 <span class="comment">% the radiometrically calibrated spectrum. Unlike so.Hu, so.Hr is the system</span>
0005 <span class="comment">% function calibrated using data from the TSL230. The result of dividing the</span>
0006 <span class="comment">% cyan LED's spectrum by so.Hr should result in a corrected and calibrated</span>
0007 <span class="comment">% cyan LED spectrum. Since direct measurements of the LED by the TSL230 weren't</span>
0008 <span class="comment">% used to calibrate, its calibration is referred to as an indirect calibration.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% This indirect calibration of the LED is compared to the direct calibration</span>
0011 <span class="comment">% generated by using a measurement from the TSL230 and TSL230_fO_to_irradiance().</span>
0012 <span class="comment">% The measurement conditions were favorable such that both the indirect and</span>
0013 <span class="comment">% direct calibrations agree with each other. However, this might not always be</span>
0014 <span class="comment">% the case.</span>
0015 
0016 <span class="comment">% NB: It's best to always take TSL230 measurements of both the incandescent</span>
0017 <span class="comment">% radiometric calibration lamp and the light source of interest. The first</span>
0018 <span class="comment">% measurement is used to scale the model of the incandescent lamp's spectrum</span>
0019 <span class="comment">% so that the system function will be scaled properly. The second measurement</span>
0020 <span class="comment">% is used to scale the corrected spectrum of the light source of interest so</span>
0021 <span class="comment">% that it agrees with what the TSL230 saw.</span>
0022 <span class="comment">%</span>
0023 <span class="comment">% After taking the spectrograph while the LED was pointed at the slit, I re-aimed</span>
0024 <span class="comment">% the LED directly at the irradiance sensor. This was necessary because the LED</span>
0025 <span class="comment">% is very directional. If your light source's radiation pattern is the same at</span>
0026 <span class="comment">% the slit and TSL230 then you can take the irradiance measurement the same time</span>
0027 <span class="comment">% you snap a spectrograph (i.e. you don't have to re-aim the light source).</span>
0028 <span class="comment">%</span>
0029 <span class="comment">% call spectrometer_setup and system_function_calibrated before running this script.</span>
0030 <span class="comment">%</span>
0031 
0032 s = filesep;
0033 so = access_spectrometer_object();
0034 
0035 <span class="comment">% the range of wavelengths where the spectrogram isn't mostly noise</span>
0036 l0 = 435; <span class="comment">% [nm]</span>
0037 lf = 600; <span class="comment">% [nm]</span>
0038 
0039 smooth_width = 11;
0040 Ftri = triang(smooth_width);
0041 Ftri = Ftri./sum(Ftri);
0042 
0043 sd = [so.dir_light s <span class="string">'spectrographs'</span> s <span class="string">'Cyan_LED_3'</span>];
0044 load([sd s so.ftype <span class="string">'_Cyan_LED_3_e0.mat'</span> ]);
0045 
0046 sensor_type = metadata.sensor_type;
0047 fO = str2double(metadata.TSL230_fO); <span class="comment">% [kHz]</span>
0048 sensitivity = str2double(metadata.TSL230_sensitivity);
0049 distance = str2double(metadata.distance); <span class="comment">% [m]</span>
0050 
0051 [ign, n0] = min(abs(so.lambda-l0));
0052 [ign, nf] = min(abs(so.lambda-lf));
0053 
0054 Z = image2spectrum(spctgrph);
0055 Z = filtfilt(Ftri, 1, Z); <span class="comment">% distorted spectrum, [count]</span>
0056 Ee = Z./so.Hr; <span class="comment">% spectral irradiance, [W/m^2/nm]</span>
0057 Ee_green = Ee(n0:nf,2); <span class="comment">% the green channel only</span>
0058 
0059 E1 = trapz(Ee_green).*(so.dlambda);
0060 
0061 disp([<span class="string">'irradiance (E1) : '</span> num2str(E1) <span class="string">' W/m^2 at distance '</span><span class="cont">...</span>
0062       num2str(distance) <span class="string">' m.'</span>])
0063 
0064 <span class="comment">% Ee_green is the indirectly calibrated spectral irradiance of the cyan LED, [W/m^2/nm]</span>
0065 <span class="comment">% Ee2 is the directly calibrated spectral irradiance of the cyan LED, [W/m^2/nm]</span>
0066 Ee2 = TSL230_fO_to_irradiance(so.lambda(n0:nf), Ee_green, fO, sensitivity, sensor_type, <span class="string">'power'</span>);
0067 
0068 <span class="comment">% spectrum corrected using the irradiance meter's measurement</span>
0069 E2 = trapz(Ee2).*(so.dlambda);
0070 disp([<span class="string">'irradiance (E2) : '</span> num2str(E2) <span class="string">' W/m^2 at distance '</span><span class="cont">...</span>
0071       num2str(distance) <span class="string">' m.'</span>])
0072 
0073 pct_err = 100*(E1-E2)/E2;
0074 disp([<span class="string">'total irradiant flux percent error 100*(E1-E2)/E2: '</span> num2str(pct_err) <span class="string">'%'</span><span class="comment">%'])</span>
0075 
0076 figure, hold on
0077 plot(so.lambda(n0:nf), Ee_green, <span class="string">'g'</span>)
0078 plot(so.lambda(n0:nf), Ee2, <span class="string">'r'</span>)
0079 axis([l0 lf 0 1.1*max(Ee2)])
0080 ylabel(<span class="string">'spectral irradiance [W/m^2/nm]'</span>)
0081 xlabel(<span class="string">'wavelength [nm]'</span>)
0082 title(<span class="string">'cyan LED spectrum calibration comparison'</span>)
0083 legend(<span class="string">'indirectly calibrated'</span>, <span class="string">'directly calibrated'</span>)
0084 
0085 break <span class="comment">% uncomment to see a comparison to a Gaussian</span>
0086 <span class="comment">% model the LED's spectrum with a Gaussian.</span>
0087 h = 6.62606896*10^-34; <span class="comment">% Planck constant, [J*s]</span>
0088 c = 299792458; <span class="comment">% speed of light, [m/s]</span>
0089 Wp = h*c./(so.lambda*10^-9); <span class="comment">% [J/photon]</span>
0090 
0091 mu = 505;
0092 FWHM = 40;
0093 Xcyan = exp(-2.7726*((so.lambda-mu)/FWHM).^2);
0094 <span class="comment">%Xcyan = Wp.*exp(-2.7726*((so.lambda-mu)/FWHM).^2);</span>
0095 
0096 Ee3 = TSL230_fO_to_irradiance(so.lambda, Xcyan, fO, sensitivity, sensor_type, <span class="string">'power'</span>);
0097 
0098 E3 = trapz(Ee3(n0:nf)).*(so.dlambda);
0099 disp([<span class="string">'irradiance (E3) : '</span> num2str(E3) <span class="string">' W/m^2 at distance '</span><span class="cont">...</span>
0100       num2str(distance) <span class="string">' m.'</span>])
0101 
0102 plot(so.lambda, Ee3, <span class="string">'k'</span>)
0103 
0104 pct_err = 100*(E3-E2)/E2;
0105 disp([<span class="string">'total irradiant flux percent error 100*(E3-E2)/E2: '</span> num2str(pct_err) <span class="string">'%'</span><span class="comment">%'])</span>
0106 
0107 legend(<span class="string">'indirectly calibrated'</span>, <span class="string">'directly calibrated'</span>, <span class="string">'Gaussian model'</span>)
</pre>

</body>
</html>